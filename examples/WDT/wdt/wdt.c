/*********************************************************
*Copyright (C), 2020, Shanghai Eastsoft Microelectronics Co., Ltd
*文件名:  wdt.c
*作  者:  AE Team
*版  本:  v1.0，编译于iDesigner(v4.2.3.166) + 工具链HRCC(v1.2.0.106)
*日  期:  2020/07/08
*描  述:  WDT复位演示
          PB6：管脚翻转
          配置字中使能WDTEN，初始PB6对应的LED1闪烁一段时间，然后以约0.5s闪烁一次，如果程序中不清狗，则芯片工作一段时间会复位。
          分频比1:128,看门狗溢出时间t=256*128/32000=1.024s
*备  注:  本软件仅供学习和演示使用，对用户直接引用代码所带来的风险或后果不承担任何法律责任。
**********************************************************/
#include <hic.h>

#define CLRWDT()   {__Asm CWDT;}        //宏定义清狗指令

typedef unsigned char uchar;
uchar timer_cnt;        //计数器溢出次数

/******************************************************
函数名：void RAMclear(void)
描  述：RAM区数据清零，RAM区地址0x0000~0x03FF
输入值：无
输出值：无
返回值：无
*******************************************************/
void RAMclear(void)
{
    for (IAAH=0; IAAH<=0x03; IAAH++)
    {
        for (IAAL=0; IAAL<0xFF; IAAL++)
            IAD = 0x00;
        IAD = 0x00;
    }
}

/******************************************************
函数名：void GPIOInit(void)
描  述：首先初始化所有未用到的IO口为输出低电平
输入值：无
输出值：无
返回值：无
*******************************************************/
void GPIOInit(void)
{
    ANSL = 0xFF;        //选择对应端口为数字IO功能
	ANSH = 0xFF;
    PAT = 0x00;         //所有IO设为输出低电平
    PBT = 0x00;
    PCT = 0x00;
    PA = 0x00;
    PB = 0x00;
    PC = 0x00;
}

/**********************************************
函数名：void main(void) 
描  述：主函数
输入值：无
输出值：无
返回值：无
**********************************************/
void main(void) 
{
    uchar i;
    RAMclear();
    GPIOInit();
    WDTC = 0x16;         //分频比1:128，使能WDT预分频器，看门狗溢出时间t=256*128/32000=1.024s

/****************T8N初始化********************/
    T8NC = 0x0E;         //定时器模式，预分频1:(Fosc/2)/128
    T8NIF = 0;           //清溢出标志位
    T8NEN = 1;           //使能T8N
    for (i=0; i<200; i++)       //上电快速翻转
    {
        while (T8NIF != 1)      //等待定时器溢出
            ;
        if (i%10 == 0)
            PB6 = ~PB6;
        T8NIF = 0;
    }
    while(1)
    {
        CLRWDT();       //清狗
        while (T8NIF != 1);      //等待定时器溢出

        if (++timer_cnt == 125)        //约0.5s定时
        {
            timer_cnt = 0;
            PB6 = ~PB6;
        }  
        T8NIF = 0;     
    }
}